"""Tests for per-field merge strategies (field_merges)."""

from dataclasses import dataclass
from pathlib import Path

import pytest

from dature import FieldMergeStrategy, LoadMetadata, MergeMetadata, MergeRule, MergeStrategy, load
from dature.errors import MergeConflictError
from dature.field_path import F


class TestFieldMergesFunction:
    def test_first_wins_per_field_with_global_last_wins(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"host": "default-host", "port": 3000}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"host": "override-host", "port": 9090}')

        @dataclass
        class Config:
            host: str
            port: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                strategy=MergeStrategy.LAST_WINS,
                field_merges=(MergeRule(F[Config].host, FieldMergeStrategy.FIRST_WINS),),
            ),
            Config,
        )

        assert result.host == "default-host"
        assert result.port == 9090

    def test_last_wins_per_field_with_global_first_wins(self, tmp_path: Path):
        first = tmp_path / "first.json"
        first.write_text('{"host": "first-host", "port": 1000}')

        second = tmp_path / "second.json"
        second.write_text('{"host": "second-host", "port": 2000}')

        @dataclass
        class Config:
            host: str
            port: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(first)),
                    LoadMetadata(file_=str(second)),
                ),
                strategy=MergeStrategy.FIRST_WINS,
                field_merges=(MergeRule(F[Config].port, FieldMergeStrategy.LAST_WINS),),
            ),
            Config,
        )

        assert result.host == "first-host"
        assert result.port == 2000

    def test_append_lists(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"tags": ["a", "b"], "name": "test"}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"tags": ["c", "d"], "name": "override"}')

        @dataclass
        class Config:
            tags: list[str]
            name: str

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(MergeRule(F[Config].tags, FieldMergeStrategy.APPEND),),
            ),
            Config,
        )

        assert result.tags == ["a", "b", "c", "d"]
        assert result.name == "override"

    def test_append_unique(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"tags": ["a", "b", "c"]}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"tags": ["b", "c", "d"]}')

        @dataclass
        class Config:
            tags: list[str]

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(MergeRule(F[Config].tags, FieldMergeStrategy.APPEND_UNIQUE),),
            ),
            Config,
        )

        assert result.tags == ["a", "b", "c", "d"]

    def test_prepend(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"tags": ["a", "b"]}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"tags": ["c", "d"]}')

        @dataclass
        class Config:
            tags: list[str]

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(MergeRule(F[Config].tags, FieldMergeStrategy.PREPEND),),
            ),
            Config,
        )

        assert result.tags == ["c", "d", "a", "b"]

    def test_prepend_unique(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"tags": ["a", "b", "c"]}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"tags": ["b", "c", "d"]}')

        @dataclass
        class Config:
            tags: list[str]

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(MergeRule(F[Config].tags, FieldMergeStrategy.PREPEND_UNIQUE),),
            ),
            Config,
        )

        assert result.tags == ["b", "c", "d", "a"]

    def test_max_numbers(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"priority": 5}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"priority": 10}')

        @dataclass
        class Config:
            priority: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(MergeRule(F[Config].priority, FieldMergeStrategy.MAX),),
            ),
            Config,
        )

        assert result.priority == 10

    def test_min_numbers(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"priority": 5}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"priority": 10}')

        @dataclass
        class Config:
            priority: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(MergeRule(F[Config].priority, FieldMergeStrategy.MIN),),
            ),
            Config,
        )

        assert result.priority == 5

    def test_nested_field(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"database": {"host": "localhost", "port": 5432}}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"database": {"host": "prod-host", "port": 3306}}')

        @dataclass
        class Database:
            host: str
            port: int

        @dataclass
        class Config:
            database: Database

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(MergeRule(F[Config].database.host, FieldMergeStrategy.FIRST_WINS),),
            ),
            Config,
        )

        assert result.database.host == "localhost"
        assert result.database.port == 3306

    def test_append_non_list_raises_type_error(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"value": "not-a-list"}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"value": "also-not"}')

        @dataclass
        class Config:
            value: str

        with pytest.raises(TypeError, match="APPEND strategy requires both values to be lists"):
            load(
                MergeMetadata(
                    sources=(
                        LoadMetadata(file_=str(defaults)),
                        LoadMetadata(file_=str(overrides)),
                    ),
                    field_merges=(MergeRule(F[Config].value, FieldMergeStrategy.APPEND),),
                ),
                Config,
            )

    def test_multiple_merge_rules(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"host": "default-host", "port": 3000, "tags": ["a"]}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"host": "override-host", "port": 9090, "tags": ["b"]}')

        @dataclass
        class Config:
            host: str
            port: int
            tags: list[str]

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                strategy=MergeStrategy.LAST_WINS,
                field_merges=(
                    MergeRule(F[Config].host, FieldMergeStrategy.FIRST_WINS),
                    MergeRule(F[Config].tags, FieldMergeStrategy.APPEND),
                ),
            ),
            Config,
        )

        assert result.host == "default-host"
        assert result.port == 9090
        assert result.tags == ["a", "b"]

    def test_empty_field_merges_backward_compat(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"host": "localhost", "port": 3000}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"port": 8080}')

        @dataclass
        class Config:
            host: str
            port: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(),
            ),
            Config,
        )

        assert result.host == "localhost"
        assert result.port == 8080


class TestFieldMergesDecorator:
    def test_decorator_with_field_merges(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"host": "default-host", "port": 3000, "tags": ["a"]}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"host": "override-host", "port": 9090, "tags": ["b"]}')

        meta = MergeMetadata(
            sources=(
                LoadMetadata(file_=str(defaults)),
                LoadMetadata(file_=str(overrides)),
            ),
            field_merges=(
                MergeRule(F["Config"].host, FieldMergeStrategy.FIRST_WINS),
                MergeRule(F["Config"].tags, FieldMergeStrategy.APPEND),
            ),
        )

        @load(meta)
        @dataclass
        class Config:
            host: str
            port: int
            tags: list[str]

        config = Config()
        assert config.host == "default-host"
        assert config.port == 9090
        assert config.tags == ["a", "b"]


class TestFieldMergesWithRaiseOnConflict:
    def test_field_merge_suppresses_conflict(self, tmp_path: Path):
        a = tmp_path / "a.json"
        a.write_text('{"host": "host-a"}')

        b = tmp_path / "b.json"
        b.write_text('{"host": "host-b", "port": 3000}')

        @dataclass
        class Config:
            host: str
            port: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(a)),
                    LoadMetadata(file_=str(b)),
                ),
                strategy=MergeStrategy.RAISE_ON_CONFLICT,
                field_merges=(MergeRule(F[Config].host, FieldMergeStrategy.LAST_WINS),),
            ),
            Config,
        )

        assert result.host == "host-b"
        assert result.port == 3000

    def test_field_merge_first_wins_suppresses_conflict(self, tmp_path: Path):
        a = tmp_path / "a.json"
        a.write_text('{"host": "host-a", "port": 3000}')

        b = tmp_path / "b.json"
        b.write_text('{"host": "host-b"}')

        @dataclass
        class Config:
            host: str
            port: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(a)),
                    LoadMetadata(file_=str(b)),
                ),
                strategy=MergeStrategy.RAISE_ON_CONFLICT,
                field_merges=(MergeRule(F[Config].host, FieldMergeStrategy.FIRST_WINS),),
            ),
            Config,
        )

        assert result.host == "host-a"
        assert result.port == 3000

    def test_unresolved_conflict_still_raises(self, tmp_path: Path):
        a = tmp_path / "a.json"
        a.write_text('{"host": "host-a", "port": 3000}')

        b = tmp_path / "b.json"
        b.write_text('{"host": "host-b", "port": 9090}')

        @dataclass
        class Config:
            host: str
            port: int

        with pytest.raises(MergeConflictError):
            load(
                MergeMetadata(
                    sources=(
                        LoadMetadata(file_=str(a)),
                        LoadMetadata(file_=str(b)),
                    ),
                    strategy=MergeStrategy.RAISE_ON_CONFLICT,
                    field_merges=(MergeRule(F[Config].host, FieldMergeStrategy.LAST_WINS),),
                ),
                Config,
            )

    def test_nested_field_merge_suppresses_conflict(self, tmp_path: Path):
        a = tmp_path / "a.json"
        a.write_text('{"database": {"host": "host-a"}, "name": "app"}')

        b = tmp_path / "b.json"
        b.write_text('{"database": {"host": "host-b"}}')

        @dataclass
        class Database:
            host: str

        @dataclass
        class Config:
            database: Database
            name: str

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(a)),
                    LoadMetadata(file_=str(b)),
                ),
                strategy=MergeStrategy.RAISE_ON_CONFLICT,
                field_merges=(MergeRule(F[Config].database.host, FieldMergeStrategy.LAST_WINS),),
            ),
            Config,
        )

        assert result.database.host == "host-b"
        assert result.name == "app"

    def test_all_conflicts_resolved_by_field_merges(self, tmp_path: Path):
        a = tmp_path / "a.json"
        a.write_text('{"host": "host-a", "port": 3000}')

        b = tmp_path / "b.json"
        b.write_text('{"host": "host-b", "port": 9090}')

        @dataclass
        class Config:
            host: str
            port: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(a)),
                    LoadMetadata(file_=str(b)),
                ),
                strategy=MergeStrategy.RAISE_ON_CONFLICT,
                field_merges=(
                    MergeRule(F[Config].host, FieldMergeStrategy.FIRST_WINS),
                    MergeRule(F[Config].port, FieldMergeStrategy.MAX),
                ),
            ),
            Config,
        )

        assert result.host == "host-a"
        assert result.port == 9090


class TestFieldMergesErrors:
    @pytest.mark.parametrize(
        ("strategy", "match"),
        [
            pytest.param(
                FieldMergeStrategy.APPEND,
                "APPEND strategy requires both values to be lists",
                id="append",
            ),
            pytest.param(
                FieldMergeStrategy.APPEND_UNIQUE,
                "APPEND_UNIQUE strategy requires both values to be lists",
                id="append_unique",
            ),
            pytest.param(
                FieldMergeStrategy.PREPEND,
                "PREPEND strategy requires both values to be lists",
                id="prepend",
            ),
            pytest.param(
                FieldMergeStrategy.PREPEND_UNIQUE,
                "PREPEND_UNIQUE strategy requires both values to be lists",
                id="prepend_unique",
            ),
        ],
    )
    def test_list_strategy_on_strings_raises_type_error(
        self,
        tmp_path: Path,
        strategy: FieldMergeStrategy,
        match: str,
    ):
        a = tmp_path / "a.json"
        a.write_text('{"value": "hello"}')

        b = tmp_path / "b.json"
        b.write_text('{"value": "world"}')

        @dataclass
        class Config:
            value: str

        with pytest.raises(TypeError, match=match):
            load(
                MergeMetadata(
                    sources=(
                        LoadMetadata(file_=str(a)),
                        LoadMetadata(file_=str(b)),
                    ),
                    field_merges=(MergeRule(F[Config].value, strategy),),
                ),
                Config,
            )

    @pytest.mark.parametrize(
        ("strategy", "match"),
        [
            pytest.param(
                FieldMergeStrategy.APPEND,
                "APPEND strategy requires both values to be lists",
                id="append",
            ),
            pytest.param(
                FieldMergeStrategy.APPEND_UNIQUE,
                "APPEND_UNIQUE strategy requires both values to be lists",
                id="append_unique",
            ),
            pytest.param(
                FieldMergeStrategy.PREPEND,
                "PREPEND strategy requires both values to be lists",
                id="prepend",
            ),
            pytest.param(
                FieldMergeStrategy.PREPEND_UNIQUE,
                "PREPEND_UNIQUE strategy requires both values to be lists",
                id="prepend_unique",
            ),
        ],
    )
    def test_list_strategy_on_integers_raises_type_error(
        self,
        tmp_path: Path,
        strategy: FieldMergeStrategy,
        match: str,
    ):
        a = tmp_path / "a.json"
        a.write_text('{"value": 42}')

        b = tmp_path / "b.json"
        b.write_text('{"value": 99}')

        @dataclass
        class Config:
            value: int

        with pytest.raises(TypeError, match=match):
            load(
                MergeMetadata(
                    sources=(
                        LoadMetadata(file_=str(a)),
                        LoadMetadata(file_=str(b)),
                    ),
                    field_merges=(MergeRule(F[Config].value, strategy),),
                ),
                Config,
            )

    @pytest.mark.parametrize(
        ("strategy", "match"),
        [
            pytest.param(
                FieldMergeStrategy.APPEND,
                "APPEND strategy requires both values to be lists, got list and str",
                id="append",
            ),
            pytest.param(
                FieldMergeStrategy.PREPEND,
                "PREPEND strategy requires both values to be lists, got list and str",
                id="prepend",
            ),
        ],
    )
    def test_list_strategy_mixed_types_raises_type_error(
        self,
        tmp_path: Path,
        strategy: FieldMergeStrategy,
        match: str,
    ):
        a = tmp_path / "a.json"
        a.write_text('{"value": ["a", "b"]}')

        b = tmp_path / "b.json"
        b.write_text('{"value": "not-a-list"}')

        @dataclass
        class Config:
            value: list[str]

        with pytest.raises(TypeError, match=match):
            load(
                MergeMetadata(
                    sources=(
                        LoadMetadata(file_=str(a)),
                        LoadMetadata(file_=str(b)),
                    ),
                    field_merges=(MergeRule(F[Config].value, strategy),),
                ),
                Config,
            )

    @pytest.mark.parametrize(
        "strategy",
        [
            pytest.param(FieldMergeStrategy.MAX, id="max"),
            pytest.param(FieldMergeStrategy.MIN, id="min"),
        ],
    )
    def test_max_min_on_lists_raises_type_error(
        self,
        tmp_path: Path,
        strategy: FieldMergeStrategy,
    ):
        a = tmp_path / "a.json"
        a.write_text('{"value": [1, 2]}')

        b = tmp_path / "b.json"
        b.write_text('{"value": [3, 4]}')

        @dataclass
        class Config:
            value: list[int]

        with pytest.raises(TypeError, match="requires comparable values"):
            load(
                MergeMetadata(
                    sources=(
                        LoadMetadata(file_=str(a)),
                        LoadMetadata(file_=str(b)),
                    ),
                    field_merges=(MergeRule(F[Config].value, strategy),),
                ),
                Config,
            )

    @pytest.mark.parametrize(
        "strategy",
        [
            pytest.param(FieldMergeStrategy.MAX, id="max"),
            pytest.param(FieldMergeStrategy.MIN, id="min"),
        ],
    )
    def test_max_min_on_dicts_raises_type_error(
        self,
        tmp_path: Path,
        strategy: FieldMergeStrategy,
    ):
        a = tmp_path / "a.json"
        a.write_text('{"value": {"nested": 1}}')

        b = tmp_path / "b.json"
        b.write_text('{"value": {"nested": 2}}')

        @dataclass
        class Config:
            value: dict[str, int]

        with pytest.raises(TypeError, match="requires comparable values, got dict and dict"):
            load(
                MergeMetadata(
                    sources=(
                        LoadMetadata(file_=str(a)),
                        LoadMetadata(file_=str(b)),
                    ),
                    field_merges=(MergeRule(F[Config].value, strategy),),
                ),
                Config,
            )

    @pytest.mark.parametrize(
        "strategy",
        [
            pytest.param(FieldMergeStrategy.MAX, id="max"),
            pytest.param(FieldMergeStrategy.MIN, id="min"),
        ],
    )
    def test_max_min_on_null_raises_type_error(
        self,
        tmp_path: Path,
        strategy: FieldMergeStrategy,
    ):
        a = tmp_path / "a.json"
        a.write_text('{"value": null}')

        b = tmp_path / "b.json"
        b.write_text('{"value": 10}')

        @dataclass
        class Config:
            value: int | None

        with pytest.raises(TypeError, match="requires comparable values, got NoneType and int"):
            load(
                MergeMetadata(
                    sources=(
                        LoadMetadata(file_=str(a)),
                        LoadMetadata(file_=str(b)),
                    ),
                    field_merges=(MergeRule(F[Config].value, strategy),),
                ),
                Config,
            )

    def test_field_merge_on_missing_key_in_one_source(self, tmp_path: Path):
        a = tmp_path / "a.json"
        a.write_text('{"host": "localhost"}')

        b = tmp_path / "b.json"
        b.write_text('{"host": "remote", "port": 8080}')

        @dataclass
        class Config:
            host: str
            port: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(a)),
                    LoadMetadata(file_=str(b)),
                ),
                field_merges=(MergeRule(F[Config].host, FieldMergeStrategy.FIRST_WINS),),
            ),
            Config,
        )

        assert result.host == "localhost"
        assert result.port == 8080

    def test_three_sources_field_merge(self, tmp_path: Path):
        a = tmp_path / "a.json"
        a.write_text('{"tags": ["a"]}')

        b = tmp_path / "b.json"
        b.write_text('{"tags": ["b"]}')

        c = tmp_path / "c.json"
        c.write_text('{"tags": ["c"]}')

        @dataclass
        class Config:
            tags: list[str]

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(a)),
                    LoadMetadata(file_=str(b)),
                    LoadMetadata(file_=str(c)),
                ),
                field_merges=(MergeRule(F[Config].tags, FieldMergeStrategy.APPEND),),
            ),
            Config,
        )

        assert result.tags == ["a", "b", "c"]

    def test_max_picks_larger_from_three_sources(self, tmp_path: Path):
        a = tmp_path / "a.json"
        a.write_text('{"priority": 5}')

        b = tmp_path / "b.json"
        b.write_text('{"priority": 15}')

        c = tmp_path / "c.json"
        c.write_text('{"priority": 10}')

        @dataclass
        class Config:
            priority: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(a)),
                    LoadMetadata(file_=str(b)),
                    LoadMetadata(file_=str(c)),
                ),
                field_merges=(MergeRule(F[Config].priority, FieldMergeStrategy.MAX),),
            ),
            Config,
        )

        assert result.priority == 15

    def test_min_picks_smaller_from_three_sources(self, tmp_path: Path):
        a = tmp_path / "a.json"
        a.write_text('{"priority": 5}')

        b = tmp_path / "b.json"
        b.write_text('{"priority": 15}')

        c = tmp_path / "c.json"
        c.write_text('{"priority": 10}')

        @dataclass
        class Config:
            priority: int

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(a)),
                    LoadMetadata(file_=str(b)),
                    LoadMetadata(file_=str(c)),
                ),
                field_merges=(MergeRule(F[Config].priority, FieldMergeStrategy.MIN),),
            ),
            Config,
        )

        assert result.priority == 5


class TestFieldMergesSameFieldNameNested:
    def test_first_wins_root_last_wins_nested(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"user_name": "root-first", "inner": {"user_name": "nested-first"}}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"user_name": "root-second", "inner": {"user_name": "nested-second"}}')

        @dataclass
        class Inner:
            user_name: str

        @dataclass
        class Config:
            user_name: str
            inner: Inner

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(
                    MergeRule(F[Config].user_name, FieldMergeStrategy.FIRST_WINS),
                    MergeRule(F[Config].inner.user_name, FieldMergeStrategy.LAST_WINS),
                ),
            ),
            Config,
        )

        assert result.user_name == "root-first"
        assert result.inner.user_name == "nested-second"

    def test_last_wins_root_first_wins_nested(self, tmp_path: Path):
        defaults = tmp_path / "defaults.json"
        defaults.write_text('{"user_name": "root-first", "inner": {"user_name": "nested-first"}}')

        overrides = tmp_path / "overrides.json"
        overrides.write_text('{"user_name": "root-second", "inner": {"user_name": "nested-second"}}')

        @dataclass
        class Inner:
            user_name: str

        @dataclass
        class Config:
            user_name: str
            inner: Inner

        result = load(
            MergeMetadata(
                sources=(
                    LoadMetadata(file_=str(defaults)),
                    LoadMetadata(file_=str(overrides)),
                ),
                field_merges=(
                    MergeRule(F[Config].user_name, FieldMergeStrategy.LAST_WINS),
                    MergeRule(F[Config].inner.user_name, FieldMergeStrategy.FIRST_WINS),
                ),
            ),
            Config,
        )

        assert result.user_name == "root-second"
        assert result.inner.user_name == "nested-first"
